str_cn:为了节省Lcpu RAM空间的代码，ROM中固化了BLE协议栈，RTT OS，完整的HAL代码和部分驱动代码,str_en:In order to save the code of Lcpu RAM space, the ROM has solidified the BLE protocol stack, RTT OS, complete HAL code and some driver code;
str_cn:Lcpu中，可以供客户调用的函数和变量，都通过symble file的方式放在,str_en:In Lcpu, the functions and variables that can be called by customers are placed in a symble file;
str_cn:SDK\example\ble\lcpu_general\project\ec-lb551\rom.sym 文件中，并且声明为不带__weak参数的强函数,str_en:SDK\example\ble\lcpu_general\project\ec-lb551\rom.sym file, and declared as a strong function without the __weak parameter;
str_cn:因此编写代码时，在能调用ROM代码的情况， 都会尽量调用ROM中代码,str_en:Therefore, when writing code, if the ROM code can be called, the code in the ROM will be called as much as possible;
str_cn:你在SDK中看到文件bf0_hal_i2c.c中函数HAL_I2C_Mem_Read，会参加编译，但是在链接时，该处定义成了弱函数,str_en:The function HAL_I2C_Mem_Read in the file bf0_hal_i2c.c that you see in the SDK will participate in the compilation, but at the time of linking, it is defined as a weak function;
str_cn:也有同名函数，并且不是__weak弱函数， 因此会链接到ROM的强函数代码去，因此上面的rt_kprintf并不会打印出来,str_en:There are also functions with the same name, and they are not __weak functions, so they will be linked to the strong function code in the ROM, so the above rt_kprintf will not be printed;
str_cn:如果想跑该HAL_I2C_Mem_Read的函数，替换掉ROM中的函数，先删除example\ble\lcpu_general\project\ec-lb551\rom.sym,str_en:If you want to run the function of HAL_I2C_Mem_Read and replace the function in the ROM, first delete example\ble\lcpu_general\project\ec-lb551\rom.sym;
str_cn:再命令scons -c清掉lcpu编译结果重新编译，文件中对应的0x00005621 T HAL_I2C_Mem_Read 这一行，编译链接时，由于只存在这一个HAL_I2C_Mem_Read弱函数， 就会链接这个 __weak函数,str_en:Then command scons -c to clear the lcpu compilation result and recompile. The corresponding line 0x00005621 T HAL_I2C_Mem_Read in the file, during compilation and linking, since there is only this one HAL_I2C_Mem_Read weak function, this __weak function will be linked;
str_cn:这时上图中，你添加的rt_kprintf("my own HAL_I2C_Mem_Read\r\n");打印， 就能打印出来,str_en:At this time, in the figure above, the rt_kprintf("my own HAL_I2C_Mem_Read\r\n"); print you added will be able to print out;
str_cn:确认用的是ROM内函数还是代码中函数，可以在Lcpu编译出来的map文件内搜索这个函数对应地址来确认,str_en:To confirm whether the function used is in the ROM or in the code, you can search for the corresponding address of this function in the map file compiled by Lcpu;
str_cn:目前SF32LB55X芯片，可以辨别的启动状态如下,str_en:The identifiable startup states of the current SF32LB55X chip are as follows;
str_cn:来获取启动的模式,str_en:To get the startup mode;
str_cn:注意: 上电， wdt，按键reset和HAL_PMU_Reboot四种cold root是没法区分,str_en:Note: The four cold roots of power-on, wdt, button reset, and HAL_PMU_Reboot cannot be distinguished;
str_cn:main函数， 是做完了初始化后， 起的其中一个线程的main函数,str_en:The main function is the main function of one of the threads started after the initialization is completed;
str_cn:Lcpu可以通过 ipc_send_msg_from_sensor_to_app往hcpu发消息如下，此消息能唤醒Hcpu,str_en:Lcpu can send messages to hcpu through ipc_send_msg_from_sensor_to_app as follows, this message can wake up Hcpu;
str_cn:Hcpu端醒来后，在task中，添加处理该消息的代码,str_en:After the Hcpu wakes up, add the code to handle this message in the task;
str_cn:SiFli系列MCU内部ROM已经固化了一个boot代码，MCU在不用烧录任何代码的情况下，上电就会进入boot代码，boot代码已经带了常见的flash存储驱动，通过读取外部存储固定地址Flashtable的配置来决定代码如何跳转，boot代码在读取的flashtable不对的情况下，也会一直在boot_mode代码内，可以通过PC指针的地址，对照芯片手册的`HPSYS地址映射`，来判断是否在boot_mode代码区间，boot代码所在的ROM区间地址通常如下,str_en:The internal ROM of the SiFli series MCU has solidified a boot code. In the case where the MCU does not need to burn any code, it will enter the boot code when powered on. The boot code already has common flash storage drivers, and decides how the code jumps by reading the configuration of the fixed address Flashtable of the external storage. If the flashtable read by the boot code is incorrect, it will always be within the boot_mode code. You can check whether it is in the boot_mode code interval by comparing the address of the PC pointer with the `HPSYS address mapping` in the chip manual. The ROM interval address where the boot code is located is usually as follows;
str_cn:进入boot_mode的用处,str_en:The use of entering boot_mode;
str_cn:硬件调试，可以在不烧录任何程序的情况下，判断MCU是否运行正常,str_en:Hardware debugging, can determine whether the MCU is running normally without burning any program;
str_cn:在用户程序死机或其他情形导致Jlink或者Uart不通的情况下，进入boot_mdoe模式确保正常下载程序,str_en:In the case where the user program crashes or other situations cause Jlink or Uart to be disconnected, enter the boot_mdoe mode to ensure normal program download;
str_cn:55，58，56系列MCU都有BOOT_MODE脚，BOOT_MODE拉高并且复位或上电，则会进入boot_mode，在Lcpu的默认debug串口会出现下面的log，此串口也是默认uart下载口,str_en:The 55, 58, 56 series MCUs all have a BOOT_MODE pin, pulling BOOT_MODE high and resetting or powering on will enter boot_mode, the following log will appear on the default debug serial port of Lcpu, this serial port is also the default uart download port;
str_cn:在boot_mode下，用于验证uart下载时，也可以输入help命令验证串口是否通的，如下操作,str_en:In boot_mode, to verify uart download, you can also enter the help command to verify whether the serial port is connected, the operation is as follows;
str_cn:BOOT_MODE拉高后的boot_mode的log输出，是来自内部固化ROM代码不依赖外部代码，如果没有此log，请查串口连接和MCU工作条件是否已经满足,str_en:The log output of boot_mode after BOOT_MODE is pulled high comes from the internal solidified ROM code and does not depend on external code. If there is no such log, please check whether the serial port connection and MCU working conditions have been met;
str_cn:如上图，需要用到工具`SiFli-SDK\tools\SifliTrace\SifliTrace.exe`串口连接并勾选上BOOT选项，然后重启机器，在52固化的boot代码中会等待2秒， 勾选BOOT选项后工具SifliTrace会发命令让52进入boot_mode，如果只看到`SFBL`的log没有看到后面的2条log，可能是PC的TX到MCU的RX这路uart不通,str_en:As shown in the figure above, you need to use the tool `SiFli-SDK\tools\SifliTrace\SifliTrace.exe` to connect the serial port and check the BOOT option, then restart the machine. The boot code solidified in 52 will wait for 2 seconds. After checking the BOOT option, the tool SifliTrace will send a command to let 52 enter boot_mode. If you only see the `SFBL` log and do not see the last two logs, it may be that the uart from PC's TX to MCU's RX is not connected;
str_cn:Serial:c2,Chip:2,Package:0,Rev:0,str_en:Serial:c2,Chip:2,Package:0,Rev:0;
str_cn:\ | /,str_en:\ | /;
str_cn:接收启动信息，停止它,str_en:Receive boot info, stop it;
str_cn:进入启动模式流程成功,str_en:Enter boot mode flow success;
str_cn:也可以采用工具和SifliTrace.exe一起使用,str_en:You can also use the tool and SifliTrace.exe together;
str_cn:注意,str_en:Note;
str_cn:SFBL这条log，不依赖于软件，如果没有此log，请查串口连接和MCU工作条件是否已经满足,str_en:The SFBL log does not depend on the software. If this log is not present, check whether the serial port connection and MCU operating conditions are met;
str_cn:58，56，52系列MCU都支持长按电源按键复位,str_en:MCUs in the 58, 56, and 52 series all support long-press power button reset;
str_cn:如果芯片的电源按键持续高电平超过10秒，会发生PWRKEY复位，将除RTC与IWDT以外的所有模块复位,str_en:If the power button of the chip remains high for more than 10 seconds, a PWRKEY reset will occur, resetting all modules except RTC and IWDT;
str_cn:通过PMUC寄存器WSR的PWRKEY标志可以查询是否发生过PWRKEY复位，通过PMUC寄存器WCR的PWRKEY可以清除该标志,str_en:The PWRKEY flag of the PMUC register WSR can be used to check if a PWRKEY reset has occurred, and the PWRKEY of the PMUC register WCR can clear this flag;
str_cn:其中52系列可以修改长按复位时间,str_en:Among them, the 52 series can modify the long press reset time;
str_cn:58，56无此寄存器，不支持修改,str_en:The 58 and 56 series do not have this register and do not support modification;
str_cn:PWRKEY_HARD_RESET_TIME默认参数10为10秒，可按照需要进行修改,str_en:The default parameter of PWRKEY_HARD_RESET_TIME is 10 seconds, which can be modified as needed;
str_cn:内部采用RC32计数，并不依赖外部32768晶体时钟,str_en:Internal counting uses RC32 and does not rely on an external 32768 crystal clock;
str_cn:另外按键的极性不能修改,str_en:Besides, the polarity of the button cannot be modified;
str_cn:对应代码配置在初始化函数HAL_PreInit内,str_en:The corresponding code configuration is within the initialization function HAL_PreInit;
str_cn:set pwrkey hard reset time time*32768,str_en:Set pwrkey hard reset time time*32768;
str_cn:单位,str_en:Unit;
str_cn:秒,str_en:Second;
str_cn:电源,str_en:Power;
str_cn:复位,str_en:Reset;
str_cn:标志,str_en:Flag;
str_cn:初始化,str_en:Initialization;
str_cn:寄存器,str_en:Register;
str_cn:修改,str_en:Modify;
str_cn:支持,str_en:Support;
str_cn:查询,str_en:Query;
str_cn:清除,str_en:Clear;
str_cn:依赖,str_en:Depend;
str_cn:条件,str_en:Condition;
str_cn:连接,str_en:Connection;
str_cn:工作,str_en:Work;
str_cn:模块,str_en:Module;
str_cn:发生,str_en:Happen;
str_cn:持续,str_en:Continuous;
str_cn:高电平,str_en:High level;
str_cn:长按,str_en:Long press;
str_cn:时间,str_en:Time;
str_cn:参数,str_en:Parameter;
str_cn:配置,str_en:Configuration;
str_cn:函数,str_en:Function;
str_cn:代码,str_en:Code;
str_cn:工具,str_en:Tool;
str_cn:使用,str_en:Use;
str_cn:如下,str_en:As follows;
str_cn:图,str_en:Figure;
str_cn:软件,str_en:Software;
str_cn:串口,str_en:Serial port;
str_cn:芯片,str_en:Chip;
str_cn:系列,str_en:Series;
str_cn:按键,str_en:Button;
str_cn:极性,str_en:Polarity;
str_cn:内部,str_en:Internal;
str_cn:外部,str_en:External;
str_cn:晶体,str_en:Crystal;
str_cn:时钟,str_en:Clock;
str_cn:默认,str_en:Default;
str_cn:需要,str_en:Need;
str_cn:对应,str_en:Corresponding;
str_cn:流程,str_en:Process;
str_cn:成功,str_en:Success;
str_cn:停止,str_en:Stop;
str_cn:信息,str_en:Information;
str_cn:启动,str_en:Start;
str_cn:模式,str_en:Mode;
str_cn:是否,str_en:Whether;
str_cn:已经,str_en:Already;
str_cn:满足,str_en:Satisfy;
str_cn:查看,str_en:Check;
str_cn:没有,str_en:No;
str_cn:此,str_en:This;
str_cn:请,str_en:Please;
str_cn:如果,str_en:If;
str_cn:超过,str_en:Exceed;
str_cn:所有,str_en:All;
str_cn:除,str_en:Except;
str_cn:与,str_en:And;
str_cn:将,str_en:Will;
str_cn:会,str_en:Will;
str_cn:可以,str_en:Can;
str_cn:通过,str_en:Through;
str_cn:其中,str_en:Among;
str_cn:另外,str_en:Besides;
str_cn:采用,str_en:Adopt;
str_cn:进行,str_en:Carry out;
str_cn:定义,str_en:Define;
str_cn:频率,str_en:Frequency;
str_cn:设置,str_en:Set;
str_cn:计数,str_en:Count;
str_cn:不,str_en:Not;
str_cn:能,str_en:Can;
str_cn:必须,str_en:Must;
str_cn:一起,str_en:Together;
str_cn:这条,str_en:This;
str_cn:日志,str_en:Log;
str_cn:长按,str_en:Long
