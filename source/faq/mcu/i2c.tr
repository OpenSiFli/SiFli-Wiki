str_cn:I2C的使用，需要严格的采用如下三步的方式来初始化和使用，否则存在睡眠唤醒后I2C恢复异常问题,str_en:The use of I2C requires strict adherence to the following three steps for initialization and usage, otherwise there may be issues with I2C recovery after sleep wake-up;
str_cn:第一步find I2C设备,str_en:The first step is to find the I2C device;
str_cn:第二步open I2C设备,str_en:The second step is to open the I2C device;
str_cn:第三步配置 I2C设备,str_en:The third step is to configure the I2C device;
str_cn:根本原因: 操作I2C设备，只使用了rt_i2c_bus_device_find I2C4设备，没有rt_device_open该设备,str_en:Root cause: When operating the I2C device, only rt_i2c_bus_device_find was used to find the I2C4 device, without using rt_device_open on this device;
str_cn:而我们软件架构从standby醒来后， 会看I2C设备是open状态来决定是否恢复I2C配置，由于I2C4没有被open，所以从standby醒来没有恢复I2C4配置，导致I2C4不可用,str_en:Our software architecture, upon waking up from standby, checks if the I2C device is in the open state to decide whether to restore the I2C configuration. Since I2C4 was not opened, its configuration was not restored after waking up from standby, causing I2C4 to be unavailable;
str_cn:解决方案: 添加如下open i2c4操作后，问题解决,str_en:Solution: The problem is resolved by adding the following operation to open i2c4;
str_cn:rt_i2c_configure 初始化的timeout时间设置比较短，由于线程切换的原因，I2C线程得不到执行，容易导致超时，建议150ms比较合适，设置过长，当I2C出现ERR时，会导致系统卡死在I2C线程里面,str_en:The timeout time set by rt_i2c_configure is relatively short. Due to thread switching, the I2C thread may not be executed, easily leading to a timeout. It is recommended that 150ms is appropriate. Setting it too long will cause the system to get stuck in the I2C thread when an ERR occurs in I2C;
str_cn:I2C速率和上拉电阻不匹配，I2C波形上升下降沿过缓，400Kbps推荐1.5K-2.2K上拉电阻,str_en:The I2C rate and pull-up resistor do not match, causing the rising and falling edges of the I2C waveform to be too slow. For 400Kbps, a pull-up resistor of 1.5K-2.2K is recommended;
str_cn:I2C飞线调试，飞线调试I2C设备Touch等芯片，过长总线，会出现I2C波形出现干扰毛刺，导致I2C波形识别错误,str_en:When debugging I2C devices such as Touch chips with flying wires, excessively long buses can cause interference glitches in the I2C waveform, leading to incorrect recognition of the I2C waveform;
str_cn:某些I2C设备出现Error情况下，可能SDA会被I2C外设拉低不放的情形，当SDA被拉低时，I2C控制器识别到总线忙，SDA就发不出波形，log会打印ERR,str_en:In some cases where I2C devices encounter an Error, SDA might be pulled low by the I2C peripheral and held there. When SDA is pulled low, the I2C controller detects that the bus is busy and cannot send out waveforms, and the log will print ERR;
str_cn:此时可以复位外设，通常复位方法,str_en:At this time, the peripheral can be reset. Common reset methods include;
str_cn:开关外设供电或者复位脚,str_en:Switching the peripheral power supply or reset pin;
str_cn:发送I2C bus reset(9个空clock)复位外设I2C总线，（SDK中在I2C ERR时，在HAL层已经做了复位I2C控制器和发9个空clock的操作）,str_en:Send an I2C bus reset (9 empty clocks) to reset the peripheral I2C bus (in the SDK, when an I2C ERR occurs, operations to reset the I2C controller and send 9 empty clocks have already been performed at the HAL layer);
str_cn:SDA被拉低后，I2C控制器再也发不出波形,str_en:After SDA is pulled low, the I2C controller can no longer send out waveforms;
str_cn:根本原因：SF32LB55x芯片支持i2c slave模式，而这个slave模式的地址正好在驱动中被配置成了0x12，导致识别到0x12，芯片进入了i2c slave模式,str_en:Root cause: The SF32LB55x chip supports i2c slave mode, and the address for this slave mode is configured as 0x12 in the driver, causing the chip to enter i2c slave mode when 0x12 is recognized;
str_cn:解决方案1：Lcpu这部分代码是在ROM里面，直接修改会不起效，从rom.sym删除lcpu中rom内函数：HAL_I2C_Init 并修改此处地址,str_en:Solution 1: This part of the Lcpu code is in ROM, direct modification will not take effect, delete the rom internal function HAL_I2C_Init in lcpu from rom.sym and modify the address here;
str_cn:解决方案2：在I2C4设备初始化完成后，直接重新配置该寄存器,str_en:Solution 2: After the initialization of the I2C4 device is completed, directly reconfigure the register;
