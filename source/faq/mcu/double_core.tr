str_cn:Hcpu在Lcpu唤醒状态可以使用Lcpu包括PB口、I2C、UART等全部外设资源,str_en:Hcpu can use all peripheral resources of Lcpu including PB port, I2C, UART, etc. when Lcpu is in the wake-up state;
str_cn:Hcpu在使用Lcpu外设时，Lcpu对应外设的宏定义，也需要打开,str_en:When Hcpu uses Lcpu peripherals, the macro definitions corresponding to Lcpu peripherals also need to be enabled;
str_cn:如果代码中Lcpu的GPTIM4和PWM5没有打开，Lcpu在初始化后，现有SDK代码为了省电会把这个模块关掉了，导致Hcpu操作GPTIM4输出PWM5失败,str_en:If GPTIM4 and PWM5 of Lcpu are not enabled in the code, the existing SDK code will turn off this module after Lcpu initialization to save power, causing Hcpu to fail to output PWM5 by operating GPTIM4;
str_cn:Hcpu使用Lcpu的I2C、UART、SPI资源都需要一样操作,str_en:Hcpu needs to perform the same operation when using Lcpu's I2C, UART, and SPI resources;
str_cn:各核的IO只能配置为各核拥有的资源,str_en:The IO of each core can only be configured as the resource owned by that core;
str_cn:PA05的PA05_I2C_UART功能，该IO可以配置任一组I2C或者UART来用，需要遵循PA口只能指定Hcpu有的I2C资源,str_en:The PA05_I2C_UART function of PA05, this IO can be configured to use any set of I2C or UART, but it must follow the rule that PA port can only specify the I2C resources owned by Hcpu;
str_cn:Lcpu不能使用Hcpu的PA口等外设资源，也不能访问Hcpu的寄存器，访问会出现Hardfault死机,str_en:Lcpu cannot use Hcpu's peripheral resources such as PA port, nor can it access Hcpu's registers; accessing them will cause a Hardfault crash;
str_cn:对PA口的操作，一定要放在#ifdef SOC_BF0_HCPU宏定义之类，避免Lcpu去调用PA的IO操作函数,str_en:Operations on the PA port must be placed under the #ifdef SOC_BF0_HCPU macro definition to prevent Lcpu from calling PA's IO operation functions;
str_cn:软件已规划为Hcpu唤醒时都会唤醒Lcpu，在Hcpu唤醒后，会通过HAL_HPAON_WakeCore(CORE_ID_LCPU);函数唤醒Lcpu,str_en:The software has been designed so that whenever Hcpu wakes up, it will also wake up Lcpu. After Hcpu wakes up, it will wake up Lcpu through the HAL_HPAON_WakeCore(CORE_ID_LCPU); function;
str_cn:在允许Lcpu休眠后，Hcpu此时访问Lcpu外设资源，也会出现Hardfault,str_en:After allowing Lcpu to sleep, if Hcpu accesses Lcpu's peripheral resources at this time, a Hardfault will also occur;
str_cn:可以查阅，思澈科技软件开发工具包文档，以及查看example\multicore\下两个双核通讯例程ipc_queue，data_service,str_en:You can refer to the SparkChips Software Development Kit documentation and check out the two dual-core communication routines ipc_queue and data_service under example\multicore\;
str_cn:可以采用datasevice的注册和订阅方式通讯,str_en:Communication can be carried out using the registration and subscription method of datasevice;
str_cn:调试双核通讯问题，可以查看ipc_cxt这个全局结构体变量的的具体内容,str_en:To debug dual-core communication issues, you can check the specific content of the global structure variable ipc_cxt;
str_cn:使用场景：Hcpu已经休眠情况下jlink连接调试Lcpu或者Ozone在线调试Lcpu,str_en:Usage scenario: Jlink connects to debug Lcpu or Ozone online debugs Lcpu while Hcpu is already in sleep mode;
str_cn:操作方法: 操作hwp_lpsys_cfg中寄存器SWCR的SWSEL位,str_en:Operation method: Operate the SWSEL bit of the register SWCR in hwp_lpsys_cfg;
str_cn:在Hcpu连接jlink时，执行SDK目录下对应\tools\segger\jlink_lcpu_56x.bat批处理,str_en:When Hcpu is connected to jlink, execute the corresponding \tools\segger\jlink_lcpu_56x.bat batch processing under the SDK directory;
str_cn:如果Lcpu死机发生在唤醒后比较早的地方，建议添加在Lcpu唤醒的入口处，具体参照 56X standby待机流程，但需要注意需要提前打开GPIO的配置,str_en:If Lcpu crashes early after waking up, it is recommended to add it at the entry point of Lcpu wake-up, specifically refer to the 56X standby process, but note that the GPIO configuration needs to be turned on in advance;
str_cn:Assert发生在Lcpu的data_send_proxy函数内,str_en:Assert occurs within the data_send_proxy function of Lcpu;
str_cn:看此时的tx_ring_buffer里的read_idx_mirror和write_idx_mirror是不是高16位相等，低16位一个都是0，一个都是1，反之如果高16位相等，低16位也相等，那说明buffer是空的,str_en:Check whether the high 16 bits of read_idx_mirror and write_idx_mirror in tx_ring_buffer are equal, with one low 16 bits being all 0 and the other all 1. Conversely, if the high 16 bits are equal and the low 16 bits are also equal, it means the buffer is empty;
str_cn:前16bit都为0x01AF相等，后16bit，一个是全0，一个是全1，代表buffer已满，导致的死机,str_en:The first 16 bits are both 0x01AF, which are equal, and the last 16 bits, one is all 0 and the other is all 1, indicating that the buffer is full, causing the crash;
str_cn:此类死机，通常是因为对方核（此处是Hcpu）死机了或者任务忙导致来不及处理dataservice的消息导致，需要看对方核死机或者任务忙的原因,str_en:This kind of crash is usually because the other core (here is Hcpu) has crashed or is busy, causing it to fail to handle dataservice messages in time. It is necessary to investigate the reason for the crash or task busyness of the other core;
str_cn:Hcpu,Lcpu,str_en:Hcpu, Lcpu;
str_cn:PA口,PB口,str_en:PA port, PB port;
str_cn:I2C,UART,SPI,str_en:I2C, UART, SPI;
str_cn:GPTIM4,PWM5,str_en:GPTIM4, PWM5;
str_cn:Hardfault,str_en:Hardfault;
str_cn:bsp_pinmux.c,bsp_power.c,str_en:bsp_pinmux.c, bsp_power.c;
str_cn:SOC_BF0_HCPU,str_en:SOC_BF0_HCPU;
str_cn:HAL_HPAON_WakeCore,CORE_ID_LCPU,str_en:HAL_HPAON_WakeCore, CORE_ID_LCPU;
str_cn:sifli_standby_handler,sifli_deep_handler,str_en:sifli_standby_handler, sifli_deep_handler;
str_cn:HAL_HPAON_CANCEL_LP_ACTIVE_REQUEST,str_en:HAL_HPAON_CANCEL_LP_ACTIVE_REQUEST;
str_cn:ipc_queue,data_service,str_en:ipc_queue, data_service;
str_cn:datas_register,button_service_cb,str_en:datas_register, button_service_cb;
str_cn:SENSORS_APP,sensors_service_cb,str_en:SENSORS_APP, sensors_service_cb;
str_cn:btn_service_name,str_en:btn_service_name;
str_cn:btn1,button_service_callback_key2,str_en:btn1, button_service_callback_key2;
str_cn:ipc_send_msg_from_sensor_to_app,str_en:ipc_send_msg_from_sensor_to_app;
str_cn:ipc_send_msg_from_app_to_sensor,str_en:ipc_send_msg_from_app_to_sensor;
str_cn:ipc_send_msg_from_ble_to_app,str_en:ipc_send_msg_from_ble_to_app;
str_cn:ipc_send_msg_from_app_to_ble,str_en:ipc_send_msg_from_app_to_ble;
str_cn:ipc_cxt,str_en:ipc_cxt;
str_cn:hwp_lpsys_cfg,SWCR,SWSEL,str_en:hwp_lpsys_cfg, SWCR, SWSEL;
str_cn:jlink_lcpu_56x.bat,jlink_lcpu_a0.bat,jlink_lcpu_pro.bat,str_en:jlink_lcpu_56x.bat, jlink_lcpu_a0.bat, jlink_lcpu_pro.bat;
str_cn:HAL_LPAON_ENABLE_PAD,str_en:HAL_LPAON_ENABLE_PAD;
str_cn:data_send_proxy,str_en:data_send_proxy;
str_cn:tx_ring_buffer,read_idx_mirror,write_idx_mirror,str_en:tx_ring_buffer, read_idx_mirror, write_idx_mirror;
str_cn:无内容,str_en:No content;
