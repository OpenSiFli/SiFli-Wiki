str_cn:CPU进入睡眠模式，需要满足如下条件，如出现无法睡眠，可以按下面方法逐个排查:,str_en:The CPU needs to meet the following conditions to enter sleep mode. If it cannot sleep, you can troubleshoot one by one according to the following methods;
str_cn:确认rtconfig.h中已经生成了如下宏:,str_en:Ensure that the following macros have been generated in rtconfig.h;
str_cn:开启低功耗模式,str_en:Enable low power mode;
str_cn:进入standby模式的低功耗,str_en:Enter standby mode for low power consumption;
str_cn:52系列建议关掉上面standby，改用deep休眠,str_en:It is recommended to turn off the above standby for the 52 series and switch to deep sleep;
str_cn:打开低功耗模式调试log,str_en:Turn on the low power mode debugging log;
str_cn:未禁止进入睡眠模式；,str_en:Entering sleep mode is not prohibited;
str_cn:如果程序中调用了，rt_pm_request(PM_SLEEP_MODE_IDLE);函数， 就会被禁止进入睡眠，可以通过串口输入命令 pm_dump 查看， 如果为 1或者大于1，则使能了禁止睡眠，为0，允许睡眠；,str_en:If the function rt_pm_request(PM_SLEEP_MODE_IDLE); is called in the program, entering sleep will be prohibited. You can check by entering the command pm_dump via the serial port. If the value is 1 or greater than 1, sleep prohibition is enabled; if it is 0, sleep is allowed;
str_cn:rt_pm_request(PM_SLEEP_MODE_IDLE);和 rt_pm_release(PM_SLEEP_MODE_IDLE);需要成对使用;,str_en:rt_pm_request(PM_SLEEP_MODE_IDLE); and rt_pm_release(PM_SLEEP_MODE_IDLE); need to be used in pairs;
str_cn:操作系统的定时器超时时间大于睡眠门限;,str_en:The timeout time of the operating system timer is greater than the sleep threshold;
str_cn:如果程序内， 存在低于100ms要唤醒的定时器，就不会进入睡眠，,str_en:If there is a timer in the program that needs to wake up in less than 100ms, it will not enter sleep;
str_cn:比如如下task中， 存在rt_thread_mdelay(90); 90<100，就不会睡眠，也可以串口命令 list_timer 查看timer的状态.,str_en:For example, in the following task, there exists rt_thread_mdelay(90); 90<100, so it will not sleep. You can also use the serial command list_timer to check the status of the timer;
str_cn:如果存在唤醒源，没有清掉，就不会进入睡眠， 因为睡下去，也会被唤醒，,str_en:If there are wakeup sources that haven't been cleared, it won't enter sleep because it would be woken up immediately after sleeping;
str_cn:常见的就是各个唤醒pin的电平状态不对， 比如设置的低电平唤醒， 但是该唤醒pin电平却是一直低电平.,str_en:A common issue is the incorrect level state of each wakeup pin. For instance, if it's set to wake up at a low level, but the pin level remains continuously low;
str_cn:可以通过串口命令、Jllink或者log电压，去读hcpu和lcpu的wsr寄存器，各个系列的WSR寄存器地址和各个bit的定义都会不一样，请查询对应芯片手册，对照wsr的具体唤醒源.,str_en:You can read the WSR registers of hcpu and lcpu through serial commands, Jllink, or log voltage. The addresses of the WSR registers and the definitions of each bit vary across different series. Please refer to the corresponding chip manual to compare with the specific wakeup source of WSR;
str_cn:发给送另外一个核的数据没被读走.,str_en:The data sent to another core has not been read;
str_cn:这里，可以通过Ozone连接或者dump内存用trace32，查看看ipc_ctx变量的tx buffer，来看是否存在数据没有被取走，,str_en:Here, you can connect via Ozone or dump memory using trace32 to check the tx buffer of the ipc_ctx variable to see if there is any data that hasn't been fetched;
str_cn:如下图，read_idx_mirror和write_idx_mirror正常为相等或者为空，如果不相等， 即有数据没有被取走， 会导致无法进入睡眠,如下非空数据没取走不能睡眠情况：,str_en:As shown in the figure below, read_idx_mirror and write_idx_mirror should normally be equal or empty. If they are not equal, it means that there is data that has not been fetched, which will prevent entering sleep. As shown below, non-empty data that hasn't been fetched prevents sleep:
str_cn:如下图是正常情况：,str_en:The figure below shows the normal situation:
str_cn:如下一个Hcpu由于Lcpu没有开启data service服务，缺失qid=1的通道，Hcpu发的数据，Lcpu没有取走，导致Hcpu不进入睡眠,str_en:As shown below, an Hcpu does not enter sleep because the Lcpu has not started the data service, missing the channel with qid=1. The data sent by the Hcpu was not fetched by the Lcpu, causing the Hcpu not to enter sleep;
str_cn:cpu没有进入idle进程.,str_en:The CPU did not enter the idle process;
str_cn:可以通过串口命令：list_thread看下所有线程的状态，只有除了tshell和tidle是ready的，其他应该都是suspend状态，否则会导致进入不了睡眠，,str_en:You can use the serial command: list_thread to check the status of all threads. Only tshell and tidle should be ready, others should be in the suspend state, otherwise, it will prevent entering sleep;
str_cn:如下图，我在app_watch_entry()函数中，添加了一条__asm("B .");死循环指令，导致app_watch的线程无法进入suspend，导致无法睡眠.,str_en:As shown in the figure below, I added a __asm("B ."); infinite loop instruction in the app_watch_entry() function, causing the app_watch thread to be unable to enter suspend, resulting in inability to sleep;
str_cn:list_timer的状态说明，,str_en:Explanation of the status of list_timer,
str_cn:第一列"timer"为定时器名字;,str_en:The first column "timer" is the name of the timer;
str_cn:第二列"periodic"为定时器周期（十六进制）;,str_en:The second column "periodic" is the timer period (in hexadecimal);
str_cn:第三列"timeout"为下一次定时器到来的时间戳;,str_en:The third column "timeout" is the timestamp for the next timer arrival;
str_cn:第四列"flag"为该定时器是否为激活状态;,str_en:The fourth column "flag" indicates whether the timer is active;
str_cn:生效的定时器只有"main"的定时器（延时函数也是一个定时器），唤醒周期为0x4e20（20000ms）.,str_en:The only effective timer is the "main" timer (a delay function is also a timer), with a wake-up period of 0x4e20 (20000ms);
str_cn:Lcpu不进入睡眠的原因，基本同问题## 8.1一样，可以参考## 8.1，此处只讲到几个Lcpu不通过串口命令debug的几个细节：,str_en:The reasons why Lcpu does not enter sleep are basically the same as problem ## 8.1. You can refer to ## 8.1. Here, only a few details about how Lcpu does not debug through serial commands are discussed:
str_cn:由于此时Jlink不能连接，可以在Hcpu未睡眠时，执行SDK\tools\segger\jlink_lcpu_a0.bat切换Jlink连接到Lcpu,再进行debug.,str_en:Since Jlink cannot connect at this time, you can execute SDK\tools\segger\jlink_lcpu_a0.bat to switch Jlink connection to Lcpu when Hcpu is not asleep, then proceed with debugging;
str_cn:检查是否存在唤醒源，在jlink连接到Lcpu后， mem32 0x4007001c 1 读取WSR寄存器.,str_en:Check if there are any wakeup sources. After jlink connects to Lcpu, read the WSR register with mem32 0x4007001c 1;
str_cn:发给Hcpu的数没有被读走,可以通过编译出的map文件找到ipc_ctx变量，用jlink mem32读取，打印ipc_ctx变量或者Ozone.exe连接，读取该变量是不是发送数据没有被Hcpu读走.,str_en:The data sent to Hcpu has not been read. You can find the ipc_ctx variable from the compiled map file, use jlink mem32 to read it, print the ipc_ctx variable, or connect with Ozone.exe to read whether the sent data has not been read by Hcpu;
str_cn:配置PB47为下降沿中断,str_en:Configure PB47 as a falling edge interrupt;
str_cn:使能中断,str_en:Enable interrupt;
str_cn:注册pin的中断函数，唤醒后，就会进入下面中断函数,str_en:Register the pin interrupt function, and it will enter the following interrupt function after waking up;
str_cn:如下是充电检测初始化代码说明,str_en:The following is an explanation of the charging detection initialization code;
str_cn:PB47 需加96,str_en:PB47 needs to add 96;
str_cn:查询PB47为哪个唤醒源,str_en:Query which wake-up source PB47 is;
str_cn:非唤醒pin，会assert,str_en:Non-wakeup pin, will assert;
str_cn:配置唤醒源，wakeup_pin值为0-5对应上面表格的#WKUP_PIN0 - 5,str_en:Configure the wakeup source, the value of wakeup_pin 0-5 corresponds to #WKUP_PIN0 - 5 in the table above;
str_cn:设置PB47为输入模式,str_en:Set PB47 to input mode;
str_cn:注意,str_en:Note;
str_cn:唤醒源配置为AON_PIN_MODE_NEG_EDGE或者AON_PIN_MODE_POS_EDGE边沿唤醒模式的话,str_en:If the wakeup source is configured as AON_PIN_MODE_NEG_EDGE or AON_PIN_MODE_POS_EDGE edge wakeup mode;
str_cn:AON_PIN_MODE_NEG_EDGE 和 PIN_IRQ_MODE_FALLING唤醒触发方式必须要跟pin中断触发方式一致,str_en:AON_PIN_MODE_NEG_EDGE and PIN_IRQ_MODE_FALLING wakeup trigger modes must be consistent with the pin interrupt trigger mode;
str_cn:因为清WSR是在pin中断函数HAL_GPIO_EXTI_IRQHandler里面进行的,str_en:Because clearing WSR is done in the pin interrupt function HAL_GPIO_EXTI_IRQHandler;
str_cn:否则会导致被唤醒一次后WSR寄存器没有清除，无法进入睡眠,str_en:Otherwise, it will result in the WSR register not being cleared after being awakened once, making it impossible to enter sleep;
str_cn:唤醒源配置为AON_PIN_MODE_HIGH或者AON_PIN_MODE_LOW电平触发模式的话,str_en:If the wakeup source is configured as AON_PIN_MODE_HIGH or AON_PIN_MODE_LOW level trigger mode;
str_cn:唤醒WSR标志位，不需要软件清除，电平变化后，WSR标志位，就会自动清除,str_en:The wakeup WSR flag bit does not need to be cleared by software, and the WSR flag bit will be automatically cleared after the level changes;
str_cn:常见原因1,str_en:Common cause 1;
str_cn:就是进入hibernate前配置的唤醒pin，电平异常,str_en:It is the abnormal level of the wakeup pin configured before entering hibernate;
str_cn:比如配置的PB44为低电平唤醒key脚， 但该PB44没有上拉电源，导致该pin一直为低电平，一旦进入hiberante就开机了,str_en:For example, PB44 is configured as a low-level wakeup key pin, but PB44 is not pulled up, causing the pin to always be at a low level, and once it enters hibernate, it powers on;
str_cn:常见原因2,str_en:Common cause 2;
str_cn:Lcpu的sensor中断唤醒，采用了pm_enable_pin_wakeup函数配置中断唤醒,str_en:Lcpu sensor interrupt wakeup uses pm_enable_pin_wakeup function to configure interrupt wakeup;
str_cn:此函数还默认会配置hibernate关机唤醒,str_en:This function also configures hibernate shutdown wakeup by default;
str_cn:而sensor 在关机时中断电平变化，导致睡下去又被唤醒,str_en:And the sensor's interrupt level changes during shutdown, causing it to go to sleep and then be woken up again;
str_cn:解决方案,str_en:Solution;
str_cn:pm_enable_pin_wakeup的唤醒函数调用，换成HAL_LPAON_EnableWakeupSrc(src, mode); 只配置中断唤醒，不配置关机唤醒，问题解决,str_en:Replace the wakeup function call of pm_enable_pin_wakeup with HAL_LPAON_EnableWakeupSrc(src, mode); only configure interrupt wakeup, do not configure shutdown wakeup, problem solved;
str_cn:常见原因3,str_en:Common cause 3;
str_cn:比如充电唤醒，按键唤醒后PMU的WSR标志位置1，但是用户程序没有处理去清掉该WSR标志位，导致睡眠后又醒来,str_en:For example, after charging wakeup or button wakeup, the PMU's WSR flag bit is set to 1, but the user program does not handle clearing this WSR flag bit, resulting in waking up again after sleeping;
str_cn:在进入关机前，即pm_shutdown函数内，调用HAL_PMU_CLEAR_WSR(hwp_pmuc->WSR); 先清掉WSR标志位， 再进入睡眠,str_en:Before entering shutdown, that is, within the pm_shutdown function, call HAL_PMU_CLEAR_WSR(hwp_pmuc->WSR); to clear the WSR flag bit first, then enter sleep;
str_cn:常见原因4,str_en:Common cause 4;
str_cn:没有按我们标准的操作，即HAL_PMU_EnterHibernate();被执行后，机器没有马上进入Hibernate模式，还会继续往下跑,str_en:Not following our standard operation, that is, after HAL_PMU_EnterHibernate(); is executed, the machine does not immediately enter Hibernate mode, but continues to run;
str_cn:必须要按如下图进行，先关中断，执行HAL_PMU_EnterHibernate();后，要添加while(1);死循环,str_en:It must be done as shown in the figure below, first disable interrupts, execute HAL_PMU_EnterHibernate(); then add a while(1); infinite loop;
str_cn:避免执行执行后续代码，导致死机或者重启等不可预料问题,str_en:Avoid executing subsequent code, leading to unpredictable problems such as crashes or restarts;
str_cn:进入hibernate睡眠模式后，rtc，wdt，lcpu的唤醒pin都可以唤醒整机，hcpu的唤醒pin不能唤醒hibernate的睡眠,str_en:After entering hibernate sleep mode, rtc, wdt, and lcpu wakeup pins can wake up the entire machine, but hcpu wakeup pins cannot wake up from hibernate sleep;
str_cn:唤醒后，启动相当于冷启动，程序从Hcpu开始跑,str_en:After waking up, the startup is equivalent to a cold start, and the program starts running from Hcpu;
str_cn:配置唤醒源， hcpu不能唤醒hibernate的睡眠，lcpu采用:HAL_LPAON_EnableWakeupSrc函数配置,str_en:Configure the wakeup source, hcpu cannot wake up from hibernate sleep, lcpu uses: HAL_LPAON_EnableWakeupSrc function configuration;
str_cn:对应的唤醒源，可以在SF32LB55X_Pin config_xxx.xlsx文档中找到,str_en:The corresponding wakeup source can be found in the SF32LB55X_Pin config_xxx.xlsx document;
str_cn:在函数rt_application_init_power_on_mode内可以判断冷启动的方式,str_en:The method of cold start can be determined within the function rt_application_init_power_on_mode;
str_cn:启动方式会存在变量g_pwron_mode，唤醒源会保存在g_wakeup_src,str_en:The startup method will be stored in the variable g_pwron_mode, and the wakeup source will be saved in g_wakeup_src;
str_cn:函数sys_pwron_fsm_handle_evt_init 处理，唤醒后事件,str_en:The function sys_pwron_fsm_handle_evt_init handles post-wakeup events;
str_cn:可以手动读取pmu的wsr寄存器看看状态,str_en:You can manually read the pmu's wsr register to check the status;
str_cn:代码中对应: `*wakeup_src = hwp_pmuc->WSR;`,str_en:In the code, it corresponds to: `*wakeup_src = hwp_pmuc->WSR;`;
str_cn:串口命令控制进入睡眠,str_en:Serial port command control to enter sleep;
str_cn:在main函数中， 添加rt_pm_request(PM_SLEEP_MODE_IDLE); 调用， 默认就会禁入睡眠,str_en:In the main function, add the call to rt_pm_request(PM_SLEEP_MODE_IDLE); which by default disables entering sleep;
str_cn:添加控制命令sleep,str_en:Add the control command sleep;
str_cn:串口shell，输入sleep standby，允许睡眠,str_en:Serial shell, input sleep standby, allow sleep;
str_cn:输入sleep off，不允许进入睡眠,str_en:Input sleep off, not allowed to enter sleep;
str_cn:输入sleep down 进入hibernate关机模式,str_en:Enter hibernate shutdown mode by inputting sleep down;
str_cn:标准IO口模型,str_en:Standard IO port model;
str_cn:功能描述如下,str_en:Function description is as follows;
str_cn:driving strength,str_en:Driving strength;
str_cn:output enable,str_en:Output enable;
str_cn:output,str_en:Output;
str_cn:input,str_en:Input;
str_cn:input enable,str_en:Input enable;
str_cn:pull enable,str_en:Pull enable;
str_cn:pull select,str_en:Pull select;
str_cn:组合控制可以实现日常使用的功能,str_en:Combined control can achieve functions for daily use;
str_cn:推挽输出,str_en:Push-pull output;
str_cn:开漏输出,str_en:Open-drain output;
str_cn:OE=1，O=1表示输出为高,str_en:OE=1, O=1 indicates high output;
str_cn:PE=1，PS=0 表示有下拉电阻,str_en:PE=1, PS=0 indicates there is a pull-down resistor;
str_cn:电流流动如下,str_en:Current flows as follows;
str_cn:电流值,str_en:Current value;
str_cn:对应的漏电模型模型如下,str_en:The corresponding leakage model is as follows;
str_cn:正确配置应该为,str_en:The correct configuration should be;
str_cn:PA31配置为下拉,str_en:PA31 configured as pull-down;
str_cn:PA31输出高电平,str_en:PA31 outputs high level;
str_cn:PA31配置无上下拉,str_en:PA31 configured without pull-up or pull-down;
str_cn:OE=1，O=1表示输出为低,str_en:OE=1, O=1 indicates low output;
str_cn:PE=1，PS=1 表示有上拉电阻,str_en:PE=1, PS=1 indicates there is a pull-up resistor;
str_cn:PA31配置为上拉,str_en:PA31 configured as pull-up;
str_cn:如果out 电压处于0~ VDDIO之间的某个电压，会导致input的IO单元的NMOS和PMOS处于半导通状态导致漏电,str_en:If the out voltage is at a certain voltage between 0~VDDIO, it will cause the NMOS and PMOS of the input IO unit to be in a semi-on state, causing leakage;
str_cn:依据这个漏电模型，IO内部漏电约为0uA - 200uA漏电不等,str_en:According to this leakage model, the internal leakage of IO is about 0uA - 200uA varies;
str_cn:没有调用BSP_GPIO_Set或者 rt_pin_write输出高或低电平,str_en:BSP_GPIO_Set or rt_pin_write has not been called to output high or low level;
str_cn:IO外部处于浮空状态，没有对应的上下拉固定电平,str_en:The IO is floating externally, without corresponding pull-up or pull-down fixed level;
str_cn:IO口为NC，不用的IO，不要初始化，IO默认会自带上下拉，不需要配置,str_en:The IO port is NC, unused IOs do not need to be initialized, IOs have default pull-up and pull-down, no configuration is needed;
str_cn:IO作为输出口，输出高或低电平,str_en:IO serves as an output port, outputting high or low level;
str_cn:IO作为输入口，有外部上下拉电阻或者外设能持续给予稳定的电平,str_en:IO serves as an input port, with external pull-up and pull-down resistors or peripherals that can continuously provide stable levels;
str_cn:外部存在外部上拉,str_en:External pull-up exists externally;
str_cn:IO作为输入口，外部没有上下拉，也没有外设能给予持续的稳定的电平,str_en:IO serves as an input port, there is no external pull-up or pull-down, and no peripherals can provide continuous stable levels;
str_cn:依据外部电路，配置为内部上拉或者下拉,str_en:Configure as internal pull-up or pull-down according to the external circuit;
str_cn:非唤醒IO，配置为高阻态，对应的PAD的IE位会关闭,str_en:Non-wakeup IO, configured as high impedance state, the corresponding PAD's IE bit will be turned off;
str_cn:设置为高阻,str_en:Set to high impedance;
str_cn:带唤醒功能的IO口，还有唤醒输入另一套输入通道，配置为高阻态，唤醒输入通道还有漏电风险，必须有内部或外部上拉,str_en:IO ports with wakeup function, there is another set of wakeup input channels, configured as high impedance state, there is still a risk of leakage in the wakeup input channel, there must be internal or external pull-up;
str_cn:不同芯片唤醒源IO不同，需要查看对应的Pin_config文档,str_en:Different chips have different wakeup source IOs, need to check the corresponding Pin_config document;
str_cn:普通IO（不带唤醒功能）,str_en:Ordinary IO (without wakeup function);
str_cn:在进入hibernate关机后，都为高阻态，内部不漏电，对外为高阻,str_en:After entering hibernate shutdown, all are in high impedance state, no internal leakage, externally high impedance;
str_cn:带唤醒功能的IO,str_en:IO with wakeup function;
str_cn:比普通IO多一个唤醒输入电路，这部分电路需要在hibernate下唤醒MCU，需要外部或者内部有一个内部上下拉电平，确保唤醒IO不漏电,str_en:Compared with ordinary IO, it has one more wakeup input circuit. This part of the circuit needs to wake up the MCU under hibernate, requiring an internal or external pull-up or pull-down level to ensure that the wakeup IO does not leak;
str_cn:55X hibernate关机后，pinmux的上下拉会掉电，唤醒IO内部没有带PMU的上下拉, 只能依赖外部上下拉,str_en:After 55X hibernate shutdown, the pinmux's pull-up and pull-down will lose power, the wakeup IO internally does not have PMU pull-up and pull-down, can only rely on external pull-up and pull-down;
str_cn:56X,52X hibernate关机后，pinmux的上下拉会掉电，唤醒IO另有带可配置的不掉电PMU上下拉,str_en:After 56X, 52X hibernate shutdown, the pinmux's pull-up and pull-down will lose power, the wakeup IO has another configurable non - power - loss PMU pull-up and pull-down;
str_cn:55X hibernate关机后，pinmux的上下拉掉电，唤醒IO内部没有带PMU的上下拉, 只能依赖外部上下拉,str_en:After 55X hibernate shutdown, the pinmux's pull-up and pull-down lose power, the wakeup IO internally does not have PMU pull-up and pull-down, can only rely on external pull-up and pull-down;
str_cn:在外部悬空的情况下，依据这个漏电模型，唤醒IO内部漏电约为0uA - 200uA漏电不等,str_en:In the case of external suspension, according to this leakage model, the internal leakage of the wakeup IO is about 0uA - 200uA varies;
str_cn:52X hibernate关机后，唤醒IO带可配置的PMU上下拉,str_en:After 52X hibernate shutdown, the wakeup IO has configurable PMU pull-up and pull-down;
str_cn:在hibernate关机前，配置为PMU无上下拉，而且外部也没有确定上下拉电平时,str_en:Before hibernate shutdown, configured as PMU without pull-up or pull-down, and the external circuit also does not have a determined pull-up or pull-down level;
str_cn:依据这个漏电模型（如## 8.7.2附图），唤醒IO内部漏电约为0uA - 200uA漏电不等（不同板子会有差异）,str_en:According to this leakage model (as shown in Figure ## 8.7.2), the internal leakage of the wakeup IO is approximately between 0uA and 200uA (varies depending on the board);
str_cn:正确配置如下,str_en:The correct configuration is as follows;
str_cn:pm_shutdown函数中，对唤醒IO，PA28-PA44的统一配置如下,str_en:In the pm_shutdown function, the unified configuration for wakeup IO, PA28-PA44, is as follows;
str_cn:下图，PE对应bit为上下拉使能，PS为上下拉选择,str_en:In the figure below, the PE corresponding bit is pull-up/pull-down enable, and PS is pull-up/pull-down selection;
str_cn:PA24~PA27跟PBR0~3用同一个PAD，PA24~PA44都可以用HAL_PIN_Set函数配置PMU上下拉,str_en:PA24~PA27 share the same PAD with PBR0~3, PA24~PA44 can all use the HAL_PIN_Set function to configure PMU pull-up and pull-down;
str_cn:Hibernate关机时，IO的pinmux上下拉会失效，PMU部分的上下拉不会掉电，还会存在,str_en:During Hibernate shutdown, the pinmux pull-up and pull-down of the IO will become invalid, but the pull-up and pull-down of the PMU part will not lose power and will still exist;
str_cn:52X hibernate关机后，唤醒IO带可配置的不掉电PMU上下拉,str_en:After 52X hibernate shutdown, the wakeup IO has configurable non-power-off PMU pull-up and pull-down;
str_cn:在hibernate关机前，配置为PMU上下拉与外部电平相反时,str_en:Before hibernate shutdown, when configured as PMU pull-up and pull-down opposite to the external level;
str_cn:**Hibernate下的功耗**,str_en:**Power consumption under Hibernate**;
str_cn:55系列MCU,str_en:55 series MCU;
str_cn:软件不用做任何处理，IO都已经为高阻态，因为唤醒PIN无内部上下拉，需要外部上下拉保证电平确保唤醒PIN不会漏电,str_en:The software does not need to do any processing, the IOs are already in high impedance state, because the wakeup PIN has no internal pull-up or pull-down, external pull-up or pull-down is required to ensure the level so that the wakeup PIN does not leak electricity;
str_cn:58，56，52系列MCU,str_en:58, 56, 52 series MCU;
str_cn:除了唤醒PIN外，其他IO都已经为高阻态，软件上只需要确认进入Hibernate前，已经配置好相应的正确PIN上下拉,str_en:Except for the wakeup PIN, all other IOs are already in high impedance state, the software only needs to confirm that the corresponding correct PIN pull-up and pull-down have been configured before entering Hibernate;
str_cn:52系列的还有内部3个LDO需要关掉,str_en:The 52 series also has three internal LDOs that need to be turned off;
str_cn:Hibernate通常会低于5uA，其他的耗电，都是来着外设硬件电路了,str_en:Hibernate usually consumes less than 5uA, other power consumptions come from peripheral hardware circuits;
str_cn:**Deep/Standby待机功耗**,str_en:**Deep/Standby standby power consumption**;
str_cn:首先确保Hcpu/Lcpu，都已经进入低功耗，Log已经打印pm[s],而且能pm[w]唤醒，确保睡眠唤醒过程不死机,str_en:First, ensure that Hcpu/Lcpu have entered low power consumption, Log has printed pm[s], and can be woken up by pm[w], ensuring that the sleep-wake process does not crash;
str_cn:也可以通过测量硬件的hpsys，lpsys的ldo的电压判断是否进入低功耗,str_en:It is also possible to determine whether it has entered low power consumption by measuring the voltage of the ldo of the hardware's hpsys and lpsys;
str_cn:功耗主要专注3方面,str_en:Power consumption mainly focuses on three aspects;
str_cn:外设漏电，包括MCU与外设IO电平差导致漏电,str_en:Peripheral leakage, including leakage caused by the level difference between MCU and peripheral IO;
str_cn:MCU内部IO漏电，见FAQ的IO漏电模型,str_en:Internal IO leakage of MCU, see FAQ's IO leakage model;
str_cn:常见输出高而下拉，内部上拉而外部下拉，输入口而无上下拉,str_en:Common output high and pull-down, internal pull-up and external pull-down, input port without pull-up or pull-down;
str_cn:MCU内部或者外部存储单元Flash，Psram，EMMC没有进入低功耗,str_en:Internal or external storage units Flash, Psram, EMMC of MCU have not entered low power consumption;
str_cn:最好是能拆除所有外设，让系统变成最小系统,一一排除外设漏电,str_en:The best way is to remove all peripherals, making the system into a minimal system, and eliminate peripheral leakage one by one;
str_cn:见下面代码，普通IO休眠改成高阻，唤醒pin依据外部电路配置上拉或下拉,str_en:See the code below, change the common IO sleep to high impedance, and configure the wakeup pin pull-up or pull-down according to the external circuit;
str_cn:需要使用的IO配置为高阻后，唤醒则需要配回来，否则会影响功能,str_en:After configuring the IOs that need to be used as high impedance, they need to be reconfigured after waking up, otherwise it will affect the function;
str_cn:有些外设，比如nor flash，比如QSPI的CS需要配置为高才行，配置为高阻反而会漏电更多,str_en:Some peripherals, such as nor flash, like QSPI's CS, need to be configured high, configuring them as high impedance will instead cause more leakage;
str_cn:关于第三点，依据MCU内外部flash，psrma，emmc的供电和IO，进行关电（对应IO下拉或者高阻），睡眠操作,str_en:Regarding the third point, according to the power supply and IO of the internal and external flash, psrma, emmc of the MCU, perform power-off (corresponding IO pull-down or high impedance), sleep operation;
str_cn:具体每个存储设备选择断电还是睡眠操作，需要依据从休眠唤醒后的存储设备的数据是否会丢失、是否需要保留，进出休眠的时间开销和参考内存规格书的电流参数选择满足功能的最优方案,str_en:Specifically, for each storage device, choosing between power-off or sleep operation needs to be based on whether the data of the storage device will be lost after waking up from hibernation, whether it needs to be retained, the time cost of entering and exiting hibernation, and the current parameters in the memory specification book to select the optimal solution that meets the function;
str_cn:代码块中的内容被忽略,str_en:The content in the code block is ignored;
str_cn:```{toctree} ```中的内容被忽略,str_en:The content in ```{toctree} ``` is ignored;
str_cn:链接和图片等内容被忽略,str_en:Links and images are ignored;
str_cn:非中文内容被忽略,str_en:Non-Chinese content is ignored;
str_cn:重复内容已合并,str_en:Duplicated content has been merged;
str_cn:翻译成英文,str_en:Translated into English;
str_cn:输出格式,str_en:Output format;
str_cn:结果中不能包含任何其他内容,str_en:The result cannot contain any other content;
str_cn:不同翻译对用分号分隔，并且必须换行,str_en:Different translation pairs are separated by semicolons and must be newline;
str_cn:每个翻译对必须严格按格式,str_en:Each translation pair must strictly follow the format;
str_cn:首先你要忽略链接和图片等内容,str_en:First, you need to ignore links and images, etc.;
str_cn:提取所有中文句子,str_en:Extract all Chinese sentences;
str_cn:处理完以后再对非句子的词语进行处理,str_en:After processing, handle non-sentence words;
str_cn:提取词语,str_en:Extract words;
str_cn:文本格式为markdown,str_en:The text format is markdown;
str_cn:忽略```{toctree} ```中的内容,str_en:Ignore the content in ```{toctree} ```;
str_cn:忽略非中文内容,str_en:Ignore non-Chinese content;
str_cn:合并重复内容,str_en:Merge duplicate content;
str_cn:翻译成英文,str_en:Translate into English;
str_cn:输出格式：,str_en:英译
str_cn:每个翻译对必须严格按格式：,str_en:英文内容
str_cn:不同翻译对用分号分隔，并且必须换行,str_en:Different translation pairs are separated by semicolons and
