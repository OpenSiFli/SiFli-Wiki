str_cn:思澈系列MCU为双核架构，Hcpu包含了PA口，Lcpu包含了PB口，58,56系列还包含了低功耗IO：PBR口,str_en:The MCU series of SiCh is dual-core architecture. Hcpu includes the PA port, Lcpu includes the PB port, and the 58 and 56 series also include low-power IO: PBR port;
str_cn:为了便于RTT操作系统统一操作GPIO口，目前PA,PB口，以及PBR口在RTThread操作系统的pin设备操作上，采用统一GPIO编排方式,str_en:In order to facilitate the unified operation of GPIO ports by the RTT operating system, a unified GPIO arrangement method is currently adopted for the PA, PB, and PBR ports in the pin device operations of the RTThread operating system;
str_cn:PA01即对应1, PA78对应78,str_en:PA01 corresponds to 1, PA78 corresponds to 78;
str_cn:PB口加上96，即PB0对应96，PB1对应97, PB40对应136,str_en:Add 96 to the PB port, that is, PB0 corresponds to 96, PB1 corresponds to 97, PB40 corresponds to 136;
str_cn:PBR0口加上160，即PBR0对应160,PBR1,对应161, PBR2对应162,str_en:Add 160 to the PBR0 port, that is, PBR0 corresponds to 160, PBR1 corresponds to 161, PBR2 corresponds to 162;
str_cn:PA,PB,PBR可以采用函数GET_PIN或者GET_PIN_2获取pin号,str_en:PA, PB, PBR can use the function GET_PIN or GET_PIN_2 to get the pin number;
str_cn:GET_PIN函数的第一个参数是0，1，2，分别对应PBR，GPIO1(PA)和GPIO2(PB),str_en:The first parameter of the GET_PIN function is 0, 1, 2, corresponding to PBR, GPIO1 (PA) and GPIO2 (PB);
str_cn:通过统一GPIO编排之后，就可以按照通用接口操作IO,str_en:After the unified GPIO arrangement, IO can be operated according to the general interface;
str_cn:配置为中断输入方式,str_en:Configured as interrupt input mode;
str_cn:DRV层函数不能修改GPIO的Funtion，需要用HAL层函数，默认在芯片上电或者standby醒来过程中，pin初始化BSP_PIN_Init函数内设置,str_en:The DRV layer function cannot modify the GPIO Function, need to use the HAL layer function, default set in the pin initialization BSP_PIN_Init function during chip power-on or standby wake-up process;
str_cn:Hcpu可以完全操作Lcpu的资源，包括PB口，但是Lcpu不能直接读写PA口，否则会出现Hardfault,str_en:Hcpu can fully operate the resources of Lcpu, including the PB port, but Lcpu cannot directly read and write the PA port, otherwise Hardfault will occur;
str_cn:采用pin的设备读写操作前，需要rt_pin_mode先设置mode，hal层设置了输入输出也不行,str_en:Before using the pin device for read/write operations, it is necessary to set the mode with rt_pin_mode first, even if the hal layer has set the input/output;
str_cn:standby/deep唤醒时，GPIO电平会保持不变（55系列Hcpu会有10ms保持默认上下拉状态），软件会自动恢复到最初的电平状态,str_en:When waking up from standby/deep, the GPIO level will remain unchanged (the Hcpu of the 55 series will maintain the default pull-up/pull-down state for 10ms), and the software will automatically restore to the initial level state;
str_cn:RTT层的GPIO操作，也可以参考RTT官网,str_en:The GPIO operation at the RTT layer can also refer to the RTT official website;
str_cn:在RTT操作系统还没起来时，比如drv_io.c的底层可以直接调用HAL接口的GPIO函数读写GPIO口,str_en:When the RTT operating system is not yet up, for example, the underlying drv_io.c can directly call the GPIO functions of the HAL interface to read and write the GPIO port;
str_cn:设置PA/PB功能和上下拉函数，PA/PB需用一个参数来区分,str_en:Set the PA/PB function and pull-up/pull-down function, PA/PB needs to be distinguished by one parameter;
str_cn:GPIO配置为输入输出方式，PA24配置为输入模式如下图,str_en:GPIO is configured as input/output mode, PA24 is configured as input mode as shown in the figure below;
str_cn:HAL层操作GPIO，要参数来区分hcpu和lcpu，因此不能再用DRV层把PB48 当作96+48来操作,str_en:To operate GPIO at the HAL layer, parameters are needed to distinguish between hcpu and lcpu, so it is no longer possible to operate PB48 as 96+48 at the DRV layer;
str_cn:PBR0默认是在PWR_REQ模式上，这个模式是硬件自动控制输出电平的高和低，LCPU醒的时候输出高，睡的时候输出低,str_en:PBR0 is by default in the PWR_REQ mode, this mode is where the hardware automatically controls the high and low output levels, LCPU outputs high when awake, and low when asleep;
str_cn:当有的板子用这个PIN控制大核PSRAM或者NOR的供电时，就要FORCE输出高了，以免小核睡了后，PSRAM掉电,str_en:When some boards use this PIN to control the power supply of the large core PSRAM or NOR, it is necessary to FORCE output high, to prevent PSRAM from losing power after the small core sleeps;
str_cn:下面是直接操作GPIO寄存器PA24输出高、低、翻转,str_en:Below is the direct operation of GPIO registers PA24 for high, low, and toggle output;
str_cn:下面是寄存器操作IO初始化和读写操作的示例,str_en:Below is an example of register operation for IO initialization and read/write operations;
str_cn:pin_test为测试程序,str_en:pin_test is the test program;
str_cn:设置为高,str_en:Set to high;
str_cn:设置为低,str_en:Set to low;
str_cn:切换,str_en:Toggle;
str_cn:读取引脚值,str_en:Read pin value;
str_cn:初始化引脚,str_en:Initialize pin;
str_cn:如果,str_en:If;
str_cn:否则,str_en:Else;
str_cn:端口,str_en:Port;
str_cn:值,str_en:Value;
str_cn:打印,str_en:Print;
str_cn:设置,str_en:Set;
str_cn:读取,str_en:Read;
str_cn:初始化,str_en:Initialize;
str_cn:PA29初始化为输出口,str_en:PA29 is initialized as an output port;
str_cn:PA29输出高,str_en:PA29 outputs high;
str_cn:PA29电平翻转,str_en:PA29 level flips;
str_cn:PA33配置为输入口,str_en:PA33 is configured as an input port;
str_cn:读取PA33,值非0代表高，0代表低电平,str_en:Read PA33, a non-zero value represents high, and 0 represents low level;
str_cn:PB02初始化为输出口,str_en:PB02 is initialized as an output port;
str_cn:采用串口finsh命令，对应实现函数为：`int cmd_pin(int argc, char **argv)`,str_en:Use the serial port finsh command, corresponding implementation function:`int cmd_pin(int argc, char **argv)`;
str_cn:Hcpu/Lcpu打开finsh功能后（Hcpu默认已打开），在串口console平台， 可以采用pin命令行来查看gpio状态，让GPIO输出高或低电平，比如:,str_en:After Hcpu/Lcpu enables the finsh function (Hcpu is enabled by default), on the serial console platform, you can use the pin command line to check the gpio status and let GPIO output high or low levels, such as:;
str_cn:查看所有GPIO状态,str_en:View the status of all GPIOs;
str_cn:查看120-96=24 PB24的状态,str_en:Check the status of 120-96=24 PB24;
str_cn:设置PB24为输出mode,str_en:Set PB24 to output mode;
str_cn:设置PA78输出高,str_en:Set PA78 to output high;
str_cn:设置106-96=10 PB10为功能2 I2C4_SDA功能,str_en:Set 106-96=10 PB10 to function 2 I2C4_SDA;
str_cn:获取PBR0状态,str_en:Get PBR0 status;
str_cn:采用Ozone，Jlink等工具连到MCU，读取pinmux和gpio寄存器，跟用户手册对比，是否配置正确；,str_en:Use tools like Ozone and Jlink to connect to the MCU, read the pinmux and gpio registers, and compare with the user manual to see if it is configured correctly;
str_cn:register.h中PA口对应PINMUX1_BASE或hwp_pinmux1，PB口对应PINMUX2_BASE或者hwp_pinmux2，,str_en:In register.h, the PA port corresponds to PINMUX1_BASE or hwp_pinmux1, and the PB port corresponds to PINMUX2_BASE or hwp_pinmux2;
str_cn:例如PA03的pinmux寄存器地址为：hwp_pinmux1->PAD_PA03,str_en:For example, the pinmux register address of PA03 is: hwp_pinmux1->PAD_PA03;
str_cn:PA口GPIO1_BASE或hwp_gpio1，PB口对应GPIO2_BASE或hwp_gpio2,str_en:The PA port GPIO1_BASE or hwp_gpio1, the PB port corresponds to GPIO2_BASE or hwp_gpio2;
str_cn:PBR口IO(PBR) 的输入使能、输出使能、上下拉电阻等功能可以通过 RTC 的 PBRxR 寄存器配置，比如PBR0地址为hwp_rtc->BKP0R,str_en:The input enable, output enable, pull-up and pull-down resistors of the PBR port IO (PBR) can be configured through the PBRxR register of the RTC. For example, the address of PBR0 is hwp_rtc->BKP0R;
str_cn:HCPU PA口睡眠唤醒后会先恢复到芯片默认的上下拉，如下图:,str_en:HCPU PA port will first restore to the chip's default pull-up and pull-down after sleep wake-up, as shown in the figure below:;
str_cn:这个时候用户程序还没有跑起来， 然后再执行代码pinmux.c文件BSP_IO_Init里面设置的值，,str_en:At this time, the user program has not started running, then execute the values set in BSP_IO_Init in the pinmux.c file;
str_cn:所以HCPU GPIO如果睡眠的时候电平与默认上下拉不一致，唤醒后有可能存在10ms左右的跳变；,str_en:Therefore, if the HCPU GPIO level is inconsistent with the default pull-up/pull-down during sleep, there may be a jump of about 10ms after waking up;
str_cn:LCPU PB口睡眠唤醒后，唤醒前的值可以一直保存到BSP_IO_Init函数执行，所以只要在BSP_IO_Init设置好GPIO口状态，LCPU GPIO 的值睡眠是可以保持的.,str_en:After LCPU PB port wakes up from sleep, the value before waking up can be saved until the BSP_IO_Init function is executed, so as long as the GPIO port status is set in BSP_IO_Init, the LCPU GPIO value can be maintained during sleep.;
str_cn:比如 PA03你想开机后一直保持高电平，但由于PA03默认是下拉的，所以睡眠唤醒后会有10ms左右的低电平，再实际使用中，你需要找个默认是上拉的脚来替换PA03，比如PA10.,str_en:For example, if you want PA03 to remain high after booting, but since PA03 defaults to pull-down, there will be about 10ms of low level after waking up from sleep. In actual use, you need to find a pin that defaults to pull-up to replace PA03, such as PA10.;
str_cn:56X,52X系列PA口不存在此问题,str_en:This issue does not exist for the 56X, 52X series PA ports;
str_cn:配置完， 会在rtconfig.h中生成:,str_en:After configuration, it will be generated in rtconfig.h:;
str_cn:需要确认该IO口的模式和上下拉状态,str_en:Need to confirm the mode and pull-up/pull-down status of this IO port;
str_cn:GPIO模式，无上拉,str_en:GPIO mode, no pull-up;
str_cn:在drv_touch.c会用到该定义，驱动可以直接使用drv_touch.c中两个函数,str_en:This definition will be used in drv_touch.c. The driver can directly use the two functions in drv_touch.c;
str_cn:或者自己在初始化函数中定义该中断,str_en:Or define the interrupt yourself in the initialization function;
str_cn:配置为input,str_en:Configured as input;
str_cn:配置下降沿中断和中断回调函数,str_en:Configure falling edge interrupt and interrupt callback function;
str_cn:使能中断,str_en:Enable interrupt;
str_cn:Hcpu的串口输入命令：pin status 79 确认该配置是否正确,str_en:Hcpu's serial port input command: pin status 79 to confirm whether the configuration is correct;
str_cn:在touch驱动deinit函数中，在detach irq之前，需要先关闭该pin的中断,str_en:In the touch driver deinit function, before detaching the irq, it is necessary to first disable the interrupt of this pin;
str_cn:为什么PA55口为默认下拉口PD，但是上电我不做任何操作，PA55测试为高电平,str_en:Why PA55 is the default pull-down port PD, but when I power on, I don't do any operation, PA55 tests as high level;
str_cn:客户的OTA代码中，有对PA55进行拉高操作,str_en:In the customer's OTA code, there is an operation to pull up PA55;
str_cn:让客户在用户程序pinmux.c中，添加断点命令,str_en:Let the customer add a breakpoint command in the user program pinmux.c;
str_cn:测试PA55口，为高,str_en:Test PA55 port, it is high;
str_cn:读了相应的寄存器，有输出高的操作,str_en:Read the corresponding register, there is an operation that outputs high;
str_cn:让芯片复位,str_en:Reset the chip;
str_cn:在读寄存器值恢复正常，PA55电平也正常,str_en:Read the register value back to normal, PA55 level is also normal;
str_cn:由于用户程序是从0x10060000开始跑的，复位后是从0x10020000 OTA的代码开始跑，然后跳到用户的0x1006000的代码，而OTA代码drv_io.c中操作了，PA55，导致该现象,str_en:Since the user program starts running from 0x10060000, after reset, it starts running from the OTA code at 0x10020000, then jumps to the user's code at 0x1006000, and the OTA code drv_io.c operates PA55, causing this phenomenon;
str_cn:通常情况下，建议客户不使用PA01,str_en:Generally, it is recommended that customers do not use PA01;
str_cn:由于PA01，PA03是复用USB口功能，PA01，PA03当作GPIO使用时，要特别谨慎,str_en:Because PA01 and PA03 are multiplexed USB port functions, they must be used with particular caution when used as GPIO;
str_cn:PA01内部在active，light_sleep模式下存在18K的下拉电阻，输出高电平，否则存在漏电，standby，deep_sleep模式下18k下拉电阻不生效,str_en:Inside PA01, there is an 18K pull-down resistor in active and light_sleep modes, outputting a high level, otherwise there will be leakage current. In standby and deep_sleep modes, the 18k pull-down resistor does not take effect;
str_cn:在standby模式下，PA01，PA03输出电平不一致，会出现通过USB电路，出现漏电流,str_en:In standby mode, if the output levels of PA01 and PA03 are inconsistent, there will be leakage current through the USB circuit;
str_cn:当满足以下条件时会存在漏电约20uA,str_en:Leakage of approximately 20uA will occur when the following conditions are met;
str_cn:进入standby睡眠,str_en:Enter standby sleep;
str_cn:PA01和PA03配置电平不一致(其中一个输出高或上拉，另一个输出低或下拉),str_en:The configuration levels of PA01 and PA03 are inconsistent (one outputs high or pulls up, the other outputs low or pulls down);
str_cn:消除漏电的补丁方案：当进入睡眠时，使两个IO的电平一致，或至少将其中一个置为高阻状态(无上下拉),str_en:A patch solution to eliminate leakage: When entering sleep, make the levels of the two IOs consistent, or set at least one of them to a high-impedance state (no pull-up or pull-down);
str_cn:PA01的下拉电阻在standby和deep_sleep模式下反而不会漏电，是在active或light_sleep的时候才漏,str_en:The pull-down resistor of PA01 will not leak in standby and deep_sleep modes, but only leaks during active or light_sleep;
str_cn:高阻不仅是我们的配置，也要板子上没有上下拉,str_en:High impedance is not only our configuration, but also there should be no pull-up or pull-down on the board;
str_cn:模拟输入为Func10，关断GPIO输出，输入使能IE关闭，即为高阻态,str_en:Analog input is Func10, shutting off GPIO output, input enable IE is turned off, which means high impedance state;
str_cn:使用前，需确认MCU这边贴了32768晶体，并关闭了,str_en:Before use, it is necessary to confirm that the MCU has attached a 32768 crystal and disabled;
str_cn:使能标志位，以PB47为例,str_en:Enable flag bit, taking PB47 as an example;
str_cn:如果需要睡眠的时候保持32k输出，需要屏蔽如下截图部分,str_en:If you need to keep 32k output during sleep, you need to mask the part shown in the screenshot below;
str_cn:因为如果LPSYS_AON_ANACR_PB_AON_ISO置1，唤醒管脚PB43~PB48睡眠时就能保持电平，但代价就是不能输出32k或者lptim3控制的波形,str_en:Because if LPSYS_AON_ANACR_PB_AON_ISO is set to 1, the wake-up pins PB43~PB48 can maintain the level during sleep, but the cost is that they cannot output 32k or lptim3 controlled waveforms;
str_cn:PB为了输出32k关闭了standy下IO保持功能，因此PB口的唤醒脚PB43-48在standby模式下，由于内部上下拉不再生效，外部要必须给确定电平或者视外部连接设为输出高或者低，防止standby模式下PB43-PB48漏电,str_en:In order for PB to output 32k, the IO holding function under standy is turned off. Therefore, the wake-up pins PB43-48 of PB port in standby mode, due to the internal pull-up and pull-down no longer being effective, must be given a certain level externally or set to output high or low depending on external connections to prevent PB43-PB48 from leaking electricity in standby mode;
str_cn:Lcpu中 menuconfig → Sifli middleware → Enable button library 设置按键个数为2,str_en:In Lcpu, menuconfig → Sifli middleware → Enable button library, set the number of buttons to 2;
str_cn:Lcpu中 menuconfig → Select board peripherals → Key config 设置KEY2对应GPIO为121（96+25）,str_en:In Lcpu, menuconfig → Select board peripherals → Key config, set KEY2 corresponding GPIO to 121 (96+25);
str_cn:Lcpu中，在sensor_service.c 函数init_pin中配置KEY2的初始化和唤醒源,str_en:In Lcpu, configure the initialization and wake-up source of KEY2 in the init_pin function of sensor_service.c;
str_cn:Hcpu中，在watch_demo.c函数init_pin中配置KEY2的消息订阅,str_en:In Hcpu, configure the message subscription of KEY2 in the init_pin function of watch_demo.c;
str_cn:DS0,DS1位都置1，驱动能力最强,str_en:Set DS0 and DS1 bits to 1, the strongest driving capability;
str_cn:设置该IO为模拟输入态，该IO口对外即为高阻态,str_en:Set this IO to analog input state, and the IO port is in high impedance state to the outside;
str_cn:从高阻态恢复为原IO状态,str_en:Recover from high impedance state to the original IO state;
str_cn:原因,str_en:Reason;
str_cn:52X，其他IO的IE默认是1，而32k的两个IO是IE为默认为0,str_en:For 52X, the default IE of other IOs is 1, while the IE of the two 32K IOs is 0 by default;
str_cn:默认的流程，HAL_PIN_Set函数，不会把IE置1，而PA22,23这两个IO，而默认IE是0，所以不能输出波形,str_en:The default process, the HAL_PIN_Set function, does not set IE to 1, and for PA22 and PA23, the default IE is 0, so the waveform cannot be output;
str_cn:解决方法,str_en:Solution;
str_cn:添加HAL_PIN_SetMode函数把IO设置为正常IO后，IE位会置1，I2C可以正常输出,str_en:Add the HAL_PIN_SetMode function to set the IO as a normal IO, the IE bit will be set to 1, and I2C can output normally;
str_cn:注意,str_en:Note;
str_cn:56X的PA55,PA56两个32K IO的IE位默认位1，不存在此问题,str_en:For 56X, the IE bits of the two 32K IOs, PA55 and PA56, are 1 by default, so this issue does not exist;
str_cn:sdk版本v2.2.0后，在HAL_PIN_Set函数中，已经添加IE恢复为1操作，不需要再多添加HAL_PIN_SetMode函数,str_en:After SDK version v2.2.0, the operation to restore IE to 1 has been added in the HAL_PIN_Set function, no need to add the HAL_PIN_SetMode function anymore;
str_cn:55，58系列MCU，每个IO都是固定的I2C,UART,PWM输出口,str_en:For the 55 and 58 series MCUs, each IO is a fixed I2C, UART, PWM output port;
str_cn:从56，52系列后的MCU，为了增加IO的灵活性，如下图，变成了灵活配置,str_en:From the 56 and 52 series MCUs onwards, in order to increase the flexibility of IO, it has become flexible configuration as shown in the figure below;
str_cn:因为在HPSYS_CFG，LPSYS_CFG引入了I2CX_PINR，USART1_PINR，GPTIMX_PINR寄存器,str_en:Because the I2CX_PINR, USART1_PINR, GPTIMX_PINR registers have been introduced in HPSYS_CFG and LPSYS_CFG;
str_cn:如上图寄存器内描述：对应的I2C1，I2C2都可以配置到PA00-PA78上来输出,str_en:As described in the above register diagram: the corresponding I2C1 and I2C2 can be configured to be output on PA00-PA78;
str_cn:具体PA口可以配置哪几路I2C，UART，TIMER输出，取决于HCPU拥有哪几路I2C，UART和TIMER,str_en:Specifically, which I2C, UART, TIMER outputs can be configured on the PA port depends on which I2C, UART, and TIMER the HCPU possesses;
str_cn:注意不能把LCPU才拥有的（例如I2C5,UART5)配置到PA口，同理不能把HCPU才拥有的（例如I2C1，UART1)配置到LCPU的PB口上,str_en:Note that those owned only by LCPU (e.g., I2C5, UART5) cannot be configured to the PA port, similarly, those owned only by HCPU (e.g., I2C1, UART1) cannot be configured to the PB port of LCPU;
str_cn:详细HCPU拥有哪几路资源，可以查看芯片用户手册,str_en:For detailed information on which resources the HCPU possesses, you can refer to the chip user manual;
str_cn:代码中hpsys_cfg.h中HPSYS_CFG_TypeDef，lpsys_cfg.h中LPSYS_CFG_TypeDef，都可以查看到对应的寄存器,str_en:In the code, the corresponding registers can be viewed in HPSYS_CFG_TypeDef in hpsys_cfg.h and LPSYS_CFG_TypeDef in lpsys_cfg.h;
str_cn:另外bf0_pin_const.h文件中MCU可以配置的功能都有列出,str_en:Additionally, the functions that the MCU can configure are listed in the bf0_pin_const.h file;
str_cn:正确的配置,str_en:Correct configuration;
str_cn:错误的配置,str_en:Incorrect configuration;
