str_cn:LCD屏幕右侧绿条纹,str_en:Green stripes on the right side of the LCD screen;
str_cn:请按下图确认修改,str_en:Please confirm the modification according to the following picture;
str_cn:LCD显示花屏,str_en:LCD shows screen distortion;
str_cn:jlink连接后，敲h，让cpu停下来,str_en:After jlink connection, press h to stop the cpu;
str_cn:cmd窗口到该目录执行\release\tools\crash_dump_analyser\script\save_ram_a0.bat保存内存信息,str_en:In the cmd window, go to this directory and execute \release\tools\crash_dump_analyser\script\save_ram_a0.bat to save memory information;
str_cn:dump出内存信息,str_en:Dump out memory information;
str_cn:运行release\tools\crash_dump_analyser\simarm\t32marm.exe工具， 恢复hcpu的现场,str_en:Run the release\tools\crash_dump_analyser\simarm\t32marm.exe tool to restore the scene of hcpu;
str_cn:恢复操作,str_en:Restore operation;
str_cn:选择0x20000000地址bin时，选择hcpu_ram.bin,str_en:When selecting the bin at address 0x20000000, select hcpu_ram.bin;
str_cn:在跳出需要选择0x60000000地址的bin时， 选择psram.bin,str_en:When it pops up and needs to select the bin at address 0x60000000, select psram.bin;
str_cn:在跳出来需要选择*.axf文件时，选择你编译出来的hcpu的*.axf文件,str_en:When it pops up and you need to select a *.axf file, select the *.axf file of hcpu that you compiled;
str_cn:恢复现场后， 打开Var->watch窗口，输入要查找的drv_lcd变量，再添加到watch窗口查看,str_en:After restoring the scene, open the Var->watch window, enter the drv_lcd variable to be searched, and then add it to the watch window for viewing;
str_cn:在watch窗口展开drv_lcd的变量，发现LCD设置的窗口尺寸大小与LCD驱动不符合,str_en:Expand the drv_lcd variable in the watch window, and find that the window size set by the LCD does not match the LCD driver;
str_cn:修改rtconfig.h文件中的，配置后，花屏问题解决,str_en:Modify the configuration in the rtconfig.h file, and the screen distortion problem is solved;
str_cn:把对应littleVGL的屏设置寄存器几个宏也要改为和LCD尺寸一致,str_en:Change several macros of the corresponding littleVGL screen setting register to be consistent with the LCD size;
str_cn:TFT屏开机或唤醒时第一帧花屏,str_en:The first frame of the TFT screen is distorted when booting or waking up;
str_cn:花屏是开显示时，屏GRAM内数据不对,str_en:The screen distortion occurs when the display is turned on, and the data in the GRAM of the screen is incorrect;
str_cn:从开机显示逻辑来看，应该是先送好数， 再display_on芯片，再开背光，如果顺序错了，就会导致第一帧花屏,str_en:From the logic of the boot display, it should send the correct data first, then turn on the display_on chip, and then turn on the backlight. If the order is wrong, it will cause the first frame to be distorted;
str_cn:初始化完成后，送黑屏过去,str_en:After the initialization is completed, send a black screen over;
str_cn:参考代码中SPD2012驱动的做法，在打开屏幕之前，先通过LCDC的背景送黑屏的数据过去，清除屏幕内部的GRAM,str_en:Refer to the practice of SPD2012 driver in the reference code, before turning on the screen, send the data of the black screen through the background of LCDC first to clear the GRAM inside the screen;
str_cn:初始化读写都正常但不亮屏问题,str_en:The problem that the initialization read and write are normal but the screen does not light up;
str_cn:每个屏IC，上电后到寄存器初始化之间延时会有不同,str_en:Each screen IC will have different delays between power-on and register initialization;
str_cn:BSP_Power_Up函数中屏上电到LCD寄存器初始化init延时不够，会导致初始化时寄存器无法配置进去，导致LCD驱动不起来,str_en:If the delay from screen power-on to LCD register initialization init in the BSP_Power_Up function is not enough, it will cause the register unable to be configured during initialization, resulting in the LCD driver not being able to start;
str_cn:再LCD寄存器初始化init开始的时候，根据屏驱IC的要求添加一定延时,str_en:Add a certain delay according to the requirements of the screen drive IC at the beginning of the LCD register initialization init;
str_cn:下面列出了屏初始化需要关注的3个延时长度，延时太大会导致屏点亮变慢，延时改小时一定要依据屏IC规格书,str_en:The following lists the three delay lengths that need to be paid attention to during screen initialization. Too long delay will cause the screen to light up slowly. When reducing the delay, it must be based on the screen IC specification;
str_cn:如何从Framebuffer 导出来看图像是否正常,str_en:How to export from Framebuffer to check if the image is normal;
str_cn:从build目录*.map文件找到buf1_1全局变量的地址,str_en:Find the address of the global variable buf1_1 from the *.map file in the build directory;
str_cn:jlink保存内存值为bin文件,str_en:jlink saves memory values as bin files;
str_cn:savebin <路径> <地址> <长度>,str_en:savebin <path> <address> <length>;
str_cn:该屏是rgb565格式，占2个byte， 412x412分辨率， 长度为412x412x2=339488=0x52E20,str_en:The screen is in rgb565 format, occupying 2 bytes, with a resolution of 412x412, and the length is 412x412x2=339488=0x52E20;
str_cn:用tools\bin2bmp\bin2bmp.py 的python工具，把bin转换为bmp图片格式,str_en:Use the python tool tools\bin2bmp\bin2bmp.py to convert bin to bmp image format;
str_cn:命令如下,str_en:The command is as follows;
str_cn:旧命令,str_en:Old command;
str_cn:新命令,str_en:New command;
str_cn:支持的颜色格式: a8/rgb565/rgb888/argb8888/rgba8888,str_en:Supported color formats: a8/rgb565/rgb888/argb8888/rgba8888;
str_cn:新增了jlinkbin2bmp.py脚本，在jlink连接的情况下，从savebin到转换，一次性导出bmp图片,str_en:A new script jlinkbin2bmp.py has been added, which can export bmp images at one time from savebin to conversion when jlink is connected;
str_cn:最新使用说明，请参考：tools\bin2bmp\readme.txt文件,str_en:For the latest instructions, please refer to: tools\bin2bmp\readme.txt file;
str_cn:LCD驱动中常见的Assert死机,str_en:Common Assert crashes in LCD drivers;
str_cn:Assertion failed at function:async_send_timeout_handler, line number:876 ,(0),str_en:Assertion failed at function:async_send_timeout_handler, line number:876 ,(0);
str_cn:开了宏 LCD_GC9B71_VSYNC_ENABLE 开启了TE功能，LCD送数后会等待TE信号再进行刷屏，一直没有等到LCD的TE信号到来，超时Assert,str_en:Turned on the macro LCD_GC9B71_VSYNC_ENABLE to enable the TE function, the LCD will wait for the TE signal to refresh the screen after sending the data, but the TE signal of the LCD never arrived, causing a timeout Assert;
str_cn:OTA过程出现该assert，因为马达的默认IO是PA44, 这个项目PA44是lcd的reset信号，进入dfu会启动马达，导致LCD被误reset，LCD不再有TE信号输出，然后dfu刷屏时死机,str_en:This assert occurs during the OTA process because the default IO of the motor is PA44, and in this project, PA44 is the reset signal of the lcd. Entering dfu will start the motor, causing the LCD to be mistakenly reset, and the LCD no longer outputs TE signals, then the dfu crashes when refreshing the screen;
str_cn:灭屏按键唤醒死机,str_en:Crash when waking up by pressing the screen-off button;
str_cn:初始化LCD屏后，在TP内初始化延时过长，存在100ms的延时,str_en:After initializing the LCD screen, the initialization delay inside the TP is too long, with a delay of 100ms;
str_cn:而客户采用的rt_thread_mdelay(100);延时函数，此时Hcpu进入IDLE进程，进入睡眠,str_en:The customer uses the rt_thread_mdelay(100); delay function, at this time, Hcpu enters the IDLE process and goes to sleep;
str_cn:定时器到了后，又从standby醒来，此时LCD掉过电，LCD没有初始化过，不会有TE信号，此时继续刷之前的刷屏，死机,str_en:When the timer is up, it wakes up from standby. At this point, the LCD has lost power and has not been initialized, so there will be no TE signal. Continuing to refresh the previous screen will cause a crash;
str_cn:驱动中，不要用rt_thread_mdelay(10);延时函数,str_en:In the driver, do not use the rt_thread_mdelay(10); delay function;
str_cn:要改用：HAL_Delay(100); 或者 HAL_Delay_us(10); 函数,str_en:Instead, use: HAL_Delay(100); or HAL_Delay_us(10); functions;
str_cn:rt_thread_mdelay函数，会进行线程切换，切换到Idle进程后，就会睡眠,str_en:The rt_thread_mdelay function will perform a thread switch, and after switching to the Idle process, it will go to sleep;
str_cn:HAL_Delay函数，是死循环，不会切走到Idle进程,str_en:The HAL_Delay function is a dead loop and will not switch to the Idle process;
str_cn:通过屏驱IC的TE输出信号或者寄存器值来判断屏显示是否正常，不正常时重初始化LCD,str_en:Determine whether the screen display is normal through the TE output signal or register value of the screen drive IC, and reinitialize the LCD if it is abnormal;
str_cn:如果LCD花屏或者定屏死机时，无TE信号输出,str_en:If the LCD screen is garbled or frozen, there will be no TE signal output;
str_cn:drv_lcd.c文件中，在等待TE超时函数async_send_timeout_handler中,str_en:In the drv_lcd.c file, in the async_send_timeout_handler function waiting for TE timeout;
str_cn:采用下面红框这块代码，就能重初始化LCD,str_en:Use the code in the red box below to reinitialize the LCD;
str_cn:如果LCD花屏时，有TE信号输出，需要读取LCD寄存器值，才得知花屏状态,str_en:If the LCD screen is garbled and there is a TE signal output, it is necessary to read the LCD register value to know the garbled status;
str_cn:按照上面的方案1，先打开刷屏timeout重初始化LCD代码,str_en:According to the above solution 1, first open the screen timeout reinitialization LCD code;
str_cn:在LCD驱动的XXXX_WriteMultiplePixels送屏函数中,str_en:In the XXXX_WriteMultiplePixels send screen function of the LCD driver;
str_cn:添加读取LCD寄存器值，如果发现寄存器不对，return出去，不进行刷屏,str_en:Add reading of the LCD register value, if the register is found to be incorrect, return and do not refresh the screen;
str_cn:这时因为没有执行送屏操作，就会导致刷屏进入RT_ETIMEOUT中，依据配置`drv_lcd.assert_timeout`重初始化LCD,str_en:At this time, because the screen operation is not performed, it will cause the screen refresh to enter RT_ETIMEOUT, and reinitialize the LCD according to the configuration `drv_lcd.assert_timeout`;
str_cn:做了3次对LCD寄存器的判别，如果3次寄存器值都不对，认为LCD异常，return出去，触发刷屏timeout，重初始化LCD,str_en:Made three judgments on the LCD register, if the register values are wrong for three times, it is considered that the LCD is abnormal, return, trigger the screen refresh timeout, and reinitialize the LCD;
str_cn:像素对齐问题，需要送4的倍数的像素给屏,str_en:Pixel alignment issue, need to send a multiple of 4 pixels to the screen;
str_cn:修图：要保证开机动画，充电这种一幅图送往整屏的图像，要是偶数分辨率,str_en:Image editing: Ensure that the image sent to the entire screen for boot animation and charging is of even resolution;
str_cn:代码中，进行4倍像素对齐，比如如上图片为161x80，修改成164x80，另外3个像素填充背景色,str_en:In the code, perform 4x pixel alignment, for example, change the above image from 161x80 to 164x80, and fill the other 3 pixels with background color;
str_cn:或者丢掉一个像素为160x80,str_en:Or drop one pixel to 160x80;
str_cn:目前55x,56x系列芯片，屏驱的QSPI只支持IO0读取QSPI/SPI数据，不支持读取IO1输出的SPI数据，屏ID从IO1输出，不支持,str_en:The current 55x, 56x series chips, the QSPI of the screen drive only supports reading QSPI/SPI data from IO0, does not support reading SPI data output from IO1, and the screen ID output from IO1 is not supported;
str_cn:Interface-II方式输出，不支持,str_en:Interface-II mode output is not supported;
str_cn:屏ID从IO0输出，支持,str_en:Screen ID output from IO0 is supported;
str_cn:GPIO模拟SPI读chipid,str_en:GPIO simulates SPI to read chipid;
str_cn:目前52x系列芯片，已经支持屏驱的QSPI中IO0-IO3任一数据线，读写读取QSPI/SPI数据,str_en:The current 52x series chips already support any data line among IO0-IO3 in the QSPI of the screen drive to read and write QSPI/SPI data;
str_cn:有些屏驱IC，在初始化的时候，对读写寄存器的CLK频率有上限要求，比如不能高于20Mhz, 送屏则可以到50Mhz，可以通过如下方式修改,str_en:Some screen drive ICs have an upper limit requirement for the CLK frequency of reading and writing registers during initialization, for example, it cannot be higher than 20Mhz, but sending to the screen can reach 50Mhz, which can be modified as follows;
str_cn:默认送屏频率为.freq = 48000000, //48Mhz,str_en:The default screen sending frequency is .freq = 48000000, //48Mhz;
str_cn:在读寄存器的时候，改成2Mhz,str_en:Change to 2Mhz when reading the register;
str_cn:写寄存器GC9B71_WriteReg的时候，也可以采用如上的方法来调整clk速率,str_en:When writing to the GC9B71_WriteReg register, you can also use the above method to adjust the clk rate;
str_cn:无内容,str_en:No content;
